const svmjs = require('svm'); // https://github.com/karpathy/svmjs

const magnitude_squared = (vector) => {
  var sum = 0;
  for (const x of vector) {
    sum += Math.pow(x, 2);
  }
  return sum;
};

export default class SVMTrainer {
  constructor(converterFn) {
    this.converterFn = converterFn || (input => input); // Default to returning example as-is
    this.svm = new svmjs.SVM();
    this.svmParams = {}; // See https://github.com/karpathy/svmjs/blob/b75b71289dd81fc909a5b3fb8b1caf20fbe45121/lib/svm.js#L27
    this.labeledTrainingData = [];
  }

  /**
   * @param {Array<number>} data
   * @param {number} classId
   */
  addTrainingExample(example, classId) {
    // This SVM library only accepts 1 and -1 as labels; convert from our 0/1 labeling scheme
    const convertedExample = this.converterFn(example);
    const svmLabel = classId === 1 ? 1 : -1;
    this.labeledTrainingData.push({example: convertedExample, label: svmLabel});
  }

  train() {
    if (this.labeledTrainingData.length > 1) {
      const trainingData = this.labeledTrainingData.map(ld => ld.example);
      const trainingLabels = this.labeledTrainingData.map(ld => ld.label);
      this.svm.train(trainingData, trainingLabels, this.svmParams);
    }
  }

  /**
   * @param {Array<number>} data
   * @returns {Promise<{confidencesByClassId: [], predictedClassId: null}>}
   */
  async predict(example) {
    let result = {
      predictedClassId: null,
      confidencesByClassId: []
    };

    if (this.labeledTrainingData.length === 0) {
      return result;
    }

    let res;
    /*
     * To keep SVM behaviour consistent with KNN, if there was only one
     * data point given, force all predictions to have that label.
     */
    if (this.labeledTrainingData.length === 1) {
      res = [this.labeledTrainingData[0].label];
    } else {
      res = this.svm.predict([this.converterFn(example)]);
      // Sanity check on removeBiasTranslate logic; should be removed in final version / moved to unit tests
      console.assert(res[0] === this.unbiasedPredict(this.converterFn(example)));
    }

    // This SVM library uses 1 and -1 as labels; convert back to our 0/1 labeling scheme
    result.predictedClassId = res[0] === 1 ? 1 : 0;
    const confidences = {};
    confidences[result.predictedClassId] = 1; // TODO: Not sure if SVM has a concept of confidence (distance from boundary?)
    result.confidencesByClassId = confidences;
    return result;
  }

  detailedExplanation(fieldInfos) {
    //console.log(JSON.stringify(this.labeledTrainingData));
    //const fieldInfos = this.labeledTrainingData[0].example;
    const fieldsAndValues = [];
    for (var i = 0; i < this.svm.w.length; i++) {
      fieldsAndValues.push({
        fieldInfo: fieldInfos[i],
        absWeight: Math.abs(this.svm.w[i]),
        //absWeight: Math.pow(this.svm.w[i], 2),
        sign: this.svm.w[i] >= 0 ? 1 : -1
      });
    }
    fieldsAndValues.sort((a, b) => b.absWeight - a.absWeight);
    return fieldsAndValues;
  }

  summarize(fieldInfos) {
    const weightData = this.detailedExplanation(fieldInfos);
    //console.log(`bias: ${this.svm.b}`);
    //console.log(weightData);

    const idFields = weightData.filter(d => d.fieldInfo.fieldType === 'id');
    const attributeFields = weightData.filter(d => d.fieldInfo.fieldType === 'attribute');

    // Aggregate all the fields generated by one-hot encoding back into one per part
    // Pick the maximum value per part, since only one of these fields can be "used" for a particular input.
    const idFieldsSummary = {};
    for (const fieldWithWeight of idFields) {
      const partType = fieldWithWeight.fieldInfo.partType;
      if (!idFieldsSummary.hasOwnProperty(partType) || fieldWithWeight.absWeight > idFieldsSummary[partType]) {
        idFieldsSummary[partType] = fieldWithWeight.absWeight;
      }
    }

    const rawSummary = {};
    for (const fieldWithWeight of attributeFields) {
      const partType = fieldWithWeight.fieldInfo.partType;
      if (!rawSummary.hasOwnProperty(partType)) {
        rawSummary[partType] = 0;
      }
      rawSummary[partType] += fieldWithWeight.absWeight;
    }

    //console.log(`attribute fields only: ${JSON.stringify(rawSummary)}`);
    //console.log(`id fields only : ${JSON.stringify(idFieldsSummary)}`);

    for (const [partType, weight] of Object.entries(idFieldsSummary)) {
      if (!rawSummary.hasOwnProperty(partType)) {
        rawSummary[partType] = 0;
      }
      rawSummary[partType] += weight;
    }

    const sortedSummary = Object.entries(rawSummary)
      .map(e => {return {partType: e[0], importance: e[1]}})
      .sort((a, b) => b.importance - a.importance);

    var denominator = 0;
    for (const partWithImportance of sortedSummary) {
      denominator += partWithImportance.importance;
    }
    const sortedAndNormalizedSummary = sortedSummary.map(p => {return {partType: p.partType, importance: p.importance / denominator}});
    return sortedAndNormalizedSummary;
  }

  explainFish(fish) {
    const translatedVector = this.removeBiasTranslate(fish.knnData);

    const impactByPart = {};
    for (var i = 0; i < this.svm.w.length; i++) {
      const partType = fish.fieldInfos[i].partType;
      if (!impactByPart.hasOwnProperty(partType)) {
        impactByPart[partType] = 0;
      }

      impactByPart[partType] += this.svm.w[i] * translatedVector[i];
    }

    const sortedImpact = Object.entries(impactByPart)
      .map(e => {return {partType: e[0], impact: e[1]}})
      .sort((a, b) => Math.abs(b.impact) - Math.abs(a.impact));

    return sortedImpact;
  }

  removeBiasTranslate(vector) {
    const translationConstant = this.svm.b / magnitude_squared(this.svm.w); 
    const translationVector = this.svm.w.map(x => x * translationConstant);    

    const result = [];
    for (var i = 0; i < vector.length; i++) {
      result[i] = vector[i] + translationVector[i];
    }
    return result;
  }

  // Only needed for validation of removeBiasTranslate
  unbiasedPredict(vector) {
    const translatedVector = this.removeBiasTranslate(vector);
    var margin = 0;
    for (var i = 0; i < translatedVector.length; i++) {
      margin += this.svm.w[i] * translatedVector[i];
    }
    return margin > 0 ? 1 : -1;
  }
}
